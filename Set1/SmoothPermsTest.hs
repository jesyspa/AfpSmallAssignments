module Main where

import Data.List (find,sort)
import Data.Maybe (isJust)
import SmoothPerms
import Test.QuickCheck

fact :: Int -> Int
fact n = product [1..n]

-- In my humble opinion, this shouldn't work, and the fact the
-- concat makes it work is mildly scary.
-- allPerms :: [a] -> [[a]]
-- allPerms [] = [[]]
-- allPerms xs = concat $ foreachWithRest (\y ys -> map (y:) $ allPerms ys) xs

-- -- We could generalise these to Eq a => [a] -> Bool, but then we'd
-- -- have to specify that in main.
-- checkForeachWithRest :: [Int] -> Bool
-- checkForeachWithRest xs = all f $ foreachWithRest (,) xs
--     where f (x, y) = x `elem` xs && 1 + length y == length xs

-- We can't check all lists; takes too long.
-- checkAllPermsLength :: [Int] -> Property
-- checkAllPermsLength xs = length xs < 10 ==> length perms == fact (length xs) && xs `elem` perms
--     where perms = allPerms xs

-- | Maximum distance between two consecutive numbers in a
-- permutation
maxK :: (Num a) => a
maxK = 10

-- | Maximum length of a list to calculate permutatioins from
maxLen :: (Num a) => a
maxLen = 10

-- | Check wether a particular element is in a list
contains :: Eq a => a -> [a] -> Bool
contains x xs = isJust $ find (x==) xs

-- | Function to limit the maximum distance between two consecutive
-- values in a permutation. It is defined to avoid having 0 or negative
-- values for the distance and also to limit the number of generated
-- permutations
getK 0 = 1
getK k' = k
  where
    k'' = (abs k')
    k 
      | k'' > maxK = maxK
      | otherwise = k''

-- | Function to limit the length of the tested lists to 10 in order
-- for testing to be quick. Otherwise the number of permutations
-- can get very long
getXs :: [a] -> [a]
getXs = take maxLen

-- | The sign function. Returns 1 por positive and zero. Returns
-- -1 for negative numbers.
sgn :: (Ord a,Num a,Eq a) => a -> a
sgn x
  | x >= 0 = 1
  | otherwise = -1

-- | Given an arbitrary list, generate a smooth list using the given
-- 'Int' argument as the maximum distance between two consecutive
-- elements.
mkSmooth :: (Num a,Ord a,Integral a) => a -> [a] -> [a]
mkSmooth _ [] = []
mkSmooth _ [x] = [x]
mkSmooth k (x:xs) = foldl (\(y:ys) v -> ((y+((y-v) `mod` k)*(sgn v)):y:ys)) [x] xs

-- This function runs terribly slow which causes the most overhead
-- when testing. The reason is that linear search over the list of
-- permutations is really slow
-- | Property that checks wether an arbitrary smooth permutation is
-- in the list of all smooth permutations of a list.
smoothProp :: Int -> [Int] -> Bool
smoothProp k' xs' = contains smooth $ smooth_perms k $ sort smooth
  where
    k = getK k'
    xs = getXs xs'
    smooth = mkSmooth k xs

-- | Check wether all consecutive elements of the list are at most
-- the provided 'Int' apart from each other
isSmooth :: (Ord a,Num a,Eq a) => a -> [a] -> Bool
isSmooth k [] = True
isSmooth k [_] = True
isSmooth k (x1:x2:xs)
  | abs (x1-x2) <= k = isSmooth k (x2:xs)
  | otherwise = False

-- | Check wether the second list' is a permutation
-- of the first list
isPermutation :: Ord a => [a] -> [a] -> Bool
isPermutation xs ys = sort xs == sort ys

-- | Check wether all the lists generated by the 'smooth_perms'
-- function are permutations of the list
permutationProp :: Int -> [Int] -> Bool
permutationProp k' xs' = all (isPermutation xs) $ smooth_perms k xs
  where
    xs = getXs xs'
    k = getK k'

-- | Check wether all permutations generated by the 'smooth_perms'
-- function have the smooth property
areSmoothProp :: Int -> [Int] -> Bool
areSmoothProp k' xs' = all (isSmooth k) $ smooth_perms k xs
  where
    xs = getXs xs'
    k = getK k'


--main = quickCheck (checkForeachWithRest .&&. checkAllPermsLength)
main :: IO ()
main = quickCheck $ permutationProp .&&. areSmoothProp .&&. smoothProp
